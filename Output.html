<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Javascript Output Based Questoins</title>
</head>

<body>







    <script>
        // 1

        // let a = []
        // let b = []
        // console.warn(a == b)
        // console.warn(a === b)

        // Explanation: actually when we compare the two array either data type or strict comparison it will output false
        //because both the a and b has different location memory so comaring the different memory location it will show the ooutput false
        // False false

        // 2
        // let a = []
        // let b = a
        // console.warn(a == b)
        // console.warn(a == b)
        // now here it will show the output true because it is comparing the memory locatioon and the memory locatoin of the a and b is same like
        // we are assigning the value a to the variable b means the same memory location of a that's y it is true
        // Output: True true

        // 3
        // let a = [20]
        // let b = [20]
        // console.warn(a[0] == b[0])
        // console.warn(a[0] === b[0])

        // Explanation:
        // here it will behave in another way because here it is not comparing  the memory location
        // insted it is comparing the value of the array which is stored in the 1st index of the array
        // it like 20==20 and 20 === 20
        // Output: true,true

        // 4
        // let z = [1, 2, 3, 4, 5, 6]
        // let a = { name: "Gautam", age: 25 }
        // console.warn(...z)
        // console.warn(a.age)

        // Explanation:
        // Here in the first console it will pring the simle 1,2,3,4,5,6 it will be converted in string from array because of spread operator
        // and the 2nd console. it will pring the age of the object `a`
        // Output: 1,2,3,4,5,6 and 25

        // 5
        // console.warn(typeof NaN)

        // Explanation:
        // it will give the output of `number` and nan stands for not a number basically when we do any operation with string,object by number it will
        // show the error NaN and it also help to check whether the value is number or not
        // Output: number

        // 6
        // let arr = [1, 2, 3, 4, 5, 6];
        // arr.length = 0
        // console.warn(arr)

        // Explantaion:
        // it will show the op as empty array because we have set the length of the array to 0
        // Output: []

        // 7
        // x = 10
        // console.warn(x)
        // var x
        // Explanation :
        // because the of hoisting the declaration of the x is done at the top of the scope
        // Output: 10

        // 8
        // let a = { x: 1, y: 2 }
        // let b = a;
        // b.x = 3
        // console.warn(a)
        // console.warn(b)

        // Explantaion
        // both the value a and b are pointing to the same reference when the value is coming ffrom call by reference it will it will hold the same value to the parent also and to child also
        // and when the call by value is called the the parent value would be empty and the value get into the child
        // Output:{x: 3, y: 2} {x: 3, y: 2}


        // 9
        // for (var i = 0; i < 10; i++) {
        //     setTimeout(function () {
        //         console.warn("Value is" + i)
        //     });
        // }
        // Explanation:
        // because of the closure and setTimeOut function and the var is function scope and there will only one shared binding for the iterations
        // by the setTimeOut function gets executed because by default the setTimeOut delays the function to run in this case there is nothing so it delays 0ms
        //  the for loop has already completed and the value of the variable is 10
        // to fix this we can use let insted of var  because let has block scope but can't use const though it is block scope because the nature of the const variable
        // const is used for constant variable whose value should not and cannot be reassigned in this case if we use const the the value is going to change each time
        // Output: 10 times

        // 10
        // function hello() {
        //     console.warn("1")
        //     setTimeout(() => {
        //         console.warn("2")
        //     })
        //     console.warn("3")
        // }
        // hello()
        // Explanation:
        // 1st it will pring 1 followed by 3 and then after that it will pring the 2 because afte some delay it will print 2 because of asynchoronus settimeout
        // Output: 1 3 2

        // 11
        // let data = 10 - - 10
        // console.warn(data)
        // Explanation
        // it's simple bodmas rule that we use in maths (- * -) = +


        // 11
        // const set = new Set([1, 5, 2, 3, 4, 5])
        // console.warn(set)
        // Explanation:
        // it will automatically remove the duplicate value from the array and create new array
        // A set is js builtin object that is specially designed to hold the unique value
        // Output: Set(5){1,5,2,3,4}


        // 12
        // let data = { name: "Gautam" }
        // console.warn(delete data.name)
        // console.warn(data)
        // Explanation:
        // It will delete the property with the delete keyword and return boolean value `true`
        // when we check the data after deleting then it will reutrn empty object
        // Output: true

        // 13
        // const data = ["Gautam", "Pradep", "Rehman"];
        // const [y] = data;
        // console.warn(y)
        // Explanation
        // here it is being array destructuring extracting the 1st element of the data and assigning to the y variable
        // Output: Gautam

        // 14
        // const data = { name: "Gautam", age: 25, skill: "javascript" }
        // const { name } = data;
        // console.warn(name)
        // Question how to get the name without using . operator
        // it can be done with the help of data destructuring
        // Output Gautam

        // 15

        // let data = { name: "Gautam", age: 25, skill: "javascript" }
        // let info = { city: "Gautam", mail: "sahanigautam0446162@gmail.com" }
        // data = { ...data, ...info }
        // console.warn(data)
        // another method
        // let data = { name: "Gautam", age: 25, skill: "javascript" };
        // let info = { city: "Gautam", mail: "sahanigautam0446162@gmail.com" };

        // data = Object.assign({}, data, info);

        // console.warn(data);

        // Questions : How to merge these two object
        // We can achieve with the help of spread operator by assigning variable and spreading both the object into single variable inside {}
        // it can be achive by another method too example Object.assign() ,It performs a shallow copy of object properties, similar to the spread operator.

        // Note:
        //Object.assign() is widely supported across all modern browsers and is suitable for most scenarios where you need to merge objects.
        // Object Spread is more concise and readable but is currently a Stage 4 proposal and may require transpilation for older environments.

        // 16
        // const user = {
        //     firstName: "Gautam",
        //     getName() {
        //         const firstName = "Gautam Sahani";
        //         return this.firstName
        //     },
        // }
        // console.log(user.getName())
        //Explanation: this is due to method invocation `this` keyword is set to the object that own method
        // Output: Gautam



        // --------------------------
        //17
        // const name = "gautam";
        // console.log(name());

        // it will show the error TypeError: name is not a function because we are calling name() function which is not defined


        // 18
        // const result = false || {} || null;
        // console.log(result);
        // OP-{}
        // as we know when we use `OR ||` operator it is used to get the first truthy value and it evaluates from left to right
        // in this case false is falsy value and it goes to {} value an it found the value is truthy then it print the {} empty object
        // and return it immediately stops the execution after it gets the truthy value


        // 19
        // const result = null || false || '';
        // console.warn(result);
        // op-empty string ''
        // as we know `|| OR` it is logical operator it evaluates from left to right it always check the first truthy values
        // if it gets truthy value then it will print the first truthy value or else it will print the last value of the conditoins


        // 20
        // const result = [] || 0 || true;
        // console.warn(result)
        // op-[]
        // it will print the first truthy value as it is getting the first value as a true where it evaluates the
        // value from left to right

        // 21
        // console.log(Promise.resolve(5))
        // op-Promise {<fulfilled>: 5}
        // when we use promise reolved it return promise itself so it is fullfilled
        // specify the reason?

        // 22
        // JSON.parse()
        // OP-"undefined" is not valid JSON
        // Question: What will this method do
        // a. `Parse JSON to javascript Value`
        // b: Parse javascript object to JSON
        // c: Parse any javascript value to JSON
        // d; Parse JSON to object only



        // 23
        // let name = "Gautam"
        // function getName() {
        //     console.log(name)
        //     let name = 'Shambhu'
        // }
        // getName()
        // output:-ReferenceError: cannot access "name" before initialization
        // because of the hoisting the let and const is block scoped and var is function scoped
        // variable declared with the let and const is hoisted but not initialized with default value that's y it is showing the erro
        // the error we are getting is because of TDZ temporal dead zone



        // 24
        // let name = "Gautam"
        // function getName() {
        //     console.log(name)
        //     var name = 'Shambhu'
        // }
        // getName()
        // op:- undefined

        // because of the memory creation phase var is function scoped and var is hoisted and the value is initialized with undefined

        // 25
        // var a = 100;
        // {
        //     var a = 10;
        //     let b = 20;
        //     const c = 30;

        //     console.log(a);
        //     console.log(b);
        //     console.log(c);
        // }
        // console.log(a)
        // op:- 10,20,30,10
        // because block a is modified value of global `a` as well
        // here when var a =10 runs then 100 is replaced by 10 as it was initially in global scope
        // so if one has same name variable outside the block the variable inside the blocks shadow the outside variable
        // this is happening because of shadowing  and this happens only for var

        // 26
        // let name = "sumit"
        // function getName() {
        //     console.log(name)
        // }
        // getName()
        // output:- sumit
        // because we are accessing the let varialbe inside the function and invoking the function getName()

        // 27
        // console.log(`(x => x)('i love javascript')); here is x is returing the value of x
        // console.log(`${(x => x)('i love javascript')} to build frontend`);
        // output:- i love javascript to build frontend
        // because we are using arrow function and x is returning the i love javascript

        // 28
        // function sumValues(x, y, z) {
        //     return x + y + z;
        // }
        //console.log(sumValues([...1, 2, 3])) //1 is not iterable
        //console.log(sumValues([...[1, 2, 3]])) //op is  1,2,3, undefined undefined
        //console.log( sumValues(...[1, 2, 3])) //output is 6
        //console.log(sumValues([1, 2, 3])) //op is  1,2,3, undefined undefined

        // Options:
        // a: sumValues([...1,2,3])
        // b: sumValues([...[1,2,3]])
        // c: sumValues(...[1,2,3])
        // d: sumValues([1,2,3])


        //29
        // const name = 'cutratetraveller explore the world'
        // console.log(!typeof name === 'object') //false
        // console.log(!typeof name === 'string') //false
        // console.log(!typeof name === false) //true
        // output:- false false true
        // because our javascript execute the code line by line as it is single threaded and evaluates the value from left to right
        // when we are doing (! typeof name ) it is making the true value to false and checking the false value with the object
        // (typeof name ) op is true and we are making the true value false at begining by (!typeof name and then evaluating the value with === 'object')



        // 30
        // const name = "Join Cutratetraveller"
        // const age = 25
        // console.log(isNaN(name)) //true
        // console.log(isNaN(age)) //false
        // output:- true false
        // because it is checking whether the variable is storing the number of not


        // ------------07/24/2024
        // 31

        // let person = { name: 'Sumit' }
        // Object.seal(person)
        // question how can you modifiy the object person
        // person.push("Shambhu")
        // person.name = "Gautam" //it can be modified by this way
        // console.warn(person)
        // with this method it prevents the addition and deleteion of new properties
        // makes existing properties non configurable


        // 32
        // let data = [1, 2, 3, 4, 5] //remove the 1st and last element
        // data.shift() //removing the 1st elemtn
        // data.pop() //removing the last elemnet
        // data.push(1) //adding the elemnt at the last of the array
        // data.unshift(98) //adding the element at the 1st in array container
        // console.warn(data)

        // 33
        // convert the data into boolean false value
        // let data = "true"
        // console.warn(!data)
        // console.warn(data)
        // because whenever we keep the negation value infront of any variable conditon it will convert to boolean value if it is true convert to false and viceversa
        // Question: Convert the data into boolean true
        // let data = "true"
        // console.warn(!!data)
        // console.warn(data)
        // single negation symbol makes the value boolean value false but !! double negation value it makes the vale boolean true


        // 34
        // let data = ["gautam", "sumit", "shambhu"]
        // delete data[1]
        // console.warn(data)
        // console.log(data.length) // it will give the length 3
        // OP:- Â ['gautam', empty, 'shambhu']
        // delete keyword is used to delete both the properties and propeties value of object in js
        // it deletes the index value properties which has index of 1 here 1=sumit
        // whenever we delete it create empty space



        // 35
        // how to merge two array
        // let arr1 = ["gautam", "sumit", 'shambhu']
        // let arr2 = ["MCA", "Scinetis", 'CEO']
        // let arr2 = [1, 2, 3, 4]
        // let mergeData = [...arr1, arr2]
        // console.log(mergeData)

        // this can be done with the help of spreap operator

        // 36
        // let c = 3 ** 3
        // console.warn(c)
        // here it is used js exponentiation operator it reaises the first operand to the power of the 2nd operand
        // another simple meaning 3 square 3




        // 37
        // let a = 2
        // setTimeout(() => {
        //     console.warn(a)
        // }, 0);
        // a = 100
        // OP:- 100
        // whenever we use setTimeout setTimeInterval in js engine the stack is created and it puts all the api function at last
        // that will run after all the program loc is executed as it becomes asynchronous and when all the loc is executed
        // at last the updated value is 100 and it prints 100 because at first the value of a was initialized to 2 and after that is was initialized to 100

        // 38
        // let a = 2
        // let A = 100
        // console.warn(A)
        // OP:-100
        // it will print the op as 100 because after declaring and initializing the value to the variable it is called immediately `A`
        // here both the "a" and "A" are different variable

        // 39
        // let A10 = "Gautam"
        // let 10A ="Sumit"
        // console.warn(A10)
        // console.warn(10A)
        // console.warn(A10) this will act normal without any error but  this will console.warn(10A) throw an error because the rule of declaring the variable in javascript
        // the variable declaration of the should not start with number

        // 40
        // let a = "hello"
        // let b = `hello`
        // console.log(a === b)
        // OP:- true
        // because both the a and b are the same string value hello content the confusion is made by the template literals string can be stored
        // by doubleq quote "", single quote '' and template literals `` backticks

        // 42
        // let a = 1
        // let b = 2
        // console.log(--b === a)
        // OP:- true
        // because of perfix Decrement operator (`--b`) --b decrements the value of b by 1 before using its value in the comparison. So, b becomes 1 after this operation.

        // 43
        // let a = 1
        // let b = 1
        // let c = 2
        // console.log(a === b === --c)
        // OP:- false
        // because when we compared the value of a and b it returned the boolean value "true" not 1 and after getting the value of b = true now comparing the value
        // true === 1 that's y it is showing false because it is comparing the boolean value with 1

        // 44
        // console.log(3*3)//9
        // console.log(3**3) //3*3*3 = 27 it saying value of square of 3  * 3
        // console.log(3***3) //syntax error

        // 45
        // console.log(a)
        // var a;
        // console.log(a)
        // OP:- undefined undefined
        // because on which is above the variable declaration var a is hoisted the default value is provided undefined by the memory creation phase of execution context
        // where as another console which is after declaration of var a is also undefined because we are accessing the value of the variable which is declared but not initialized with default value

        // 46
        // how to find the os name from js
        // navigator.platform

        // 47
        // function bike() {
        //     console.log(name)
        //     console.log(price)
        //     var name = "Dominor"
        //     let price = 262000;
        // }
        // bike()
        // OP:- Undefined, Reference Error cannot access price before initialization
        // because var is hoisted and it value is also hoisted but let is hoisted but not initialized with default value the value is in TDZ

        // 48
        // for (var i = 0; i < 3; i++) {
        //     setTimeout(() => {
        //         console.log(i)
        //     }, 1);
        // }
        // OP:- 3,3,3
        // because at first loop has executed 3 time 3 and when it finishes it's execution at that time value of var i = 3 and afte that it prints 3
        //The for loop completes before any of the setTimeout callbacks execute.
        // Each callback captures and logs the final value of i (which is 3), rather than the value of i at the time setTimeout was called.
        // This results in the console outputting 3 three times instead of 0, 1, 2

        // 49
        // for (let i = 0; i < 3; i++) {
        //     setTimeout(() => {
        //         console.log(i)
        //     }, 1);
        // }
        // OP:- 0,1,2
        // because let has block scope

        // 50
        // console.log(+true)
        // console.log(typeof +true)
        // OP:- 1 and number
        // because When you apply + to a boolean value (true), JavaScript converts true to its corresponding numeric representation, which is 1.
        // Therefore, +true evaluates to 1.


        // ---------------------- 07/26/2024
        // 51
        // console.log(!"gautam")
        // console.log(typeof ('gautam'))
        // OP:- false and string
        // because we are converting the string to the opposite that y it is returning false and 2nd console we are checking the type of data and it is string


        // 52
        // let data = 'size'
        // const bird = {
        //     size: "small"
        // }
        // console.log(bird[data]) //accessing the property of the bird using the value of data
        // console.log(bird["size"]) //it is directly accessing the property `size` of the bird object
        // console.log(bird.size) //it is also directly accessing the propery  of the bird object
        // console.log(bird.data) //it is trying to access the property of the data which is not available in brid object
        // OP:- small small small undefined
        // here (.) notation and bracket [] notation are straight forward way to access the object properties directly if you know the property name in advance
        // using the variable and accessing them inside the bracket (bird[data] allows for dynamic property access based on the value of the variable


        // 53
        // let c = { name: "gatuam" }
        // let d;
        // d = c;
        // c.name = "sumit"
        // console.log(d.name)
        // OP:- sumit
        // it will print sumit because due to shared object reference, mutability and object references c and d points to the same object
        // changing c.name to sumit also changes d.name because they share the same object reference

        // 54
        // var x;
        // var x = 10
        // console.log(x)
        // OP:- 10
        // because it holds the value of 10 here first x is declared in 1st step and in 2nd step x has initialized a value of 10

        // 55
        // var x
        // let x = 10
        // console.log(x)
        //OP:- syntaxerror x has been already declared
        // because here let and const cannot be redeclared and we are declaring the same variable name with let and assigning the value


        // 56
        // let a = 3
        // let b = new Number(3)
        // console.log(a == b) //true
        // console.log(a === b) //false
        // OP:- true and false
        // because we are comparing the number with object in 1st case type coercien takes place and it convert to the same value and check the vlalue
        // whereas in 2nd console log type coercien does not take place means it is comparing number with object which is obviously false


        // 57
        // let name;
        // name = {}
        // console.log(name)
        // OP:- empty object {}
        // because we are not assingnign any properties and value to the object name

        // 58
        // function bike() {
        //     console.log("Dominor")
        // }
        // bike.name = "BMW"
        // bike()
        // OP:- Dominor
        // bike.name = "BMW";: Assigns a property "name" to the function object bike. In JavaScript, functions are objects, so you can add properties to them.
        // This is because calling bike() executes the function body, which logs "Dominor" to the console.


        // 59
        // function sum(a, b) {
        //     return a + b
        // }
        // console.log(sum(5, "10"))
        // OP:- 510
        // because it is concatenating the number with string

        // 60
        // let number = 10
        // console.log(number++) //10
        // console.log(++number)//12
        // console.log(number) //12
        // because of postfix and prefix operator
        // Postfix (number++): Returns the current value of number, then increments number by 1.
        // Prefix (++number): Increments number by 1, then returns the incremented value.

        // 61
        // let f = "8";
        // let a = 1;
        // console.log((+f) + a + 1)
        // OP:-10
        // because the expression (+f) is a shorthand way to convert the value of f to a number.Therefore (+f) evaluates to 8 

        // 62
        // let a = 10
        // if(true){
        //     let a = 20
        //     console.log(a, "inside")
        // }
        // console.log(b, "outside")
        // OP: 20 Inside and 10 Outside
        // because variable a is declared inside the block scope and does not affect the outside variable 

        // 63
        // var a = "gautam"
        // var a = "sumit"
        // console.log(a)
        // OP:- sumit
        // here the variable is decalared with var keyword in which we can redeclare and assign value it overrides the previous variable value

        // 64
        // const arr1 = [1, 2, 3, 4];
        // const arr2 = [6, 7, 5];
        // const result = [...arr1, ...arr2];
        // console.log(result);
        // OP:- result [1,2,3,4,6,7,5]
        // here we are concatenating the two array into a single array with the spread operator [...]

        // 65
        // const person1 = { name: "sumit", age: 17, }
        // const person2 = { city: "Parasi", ...person1 }
        // console.log(person2)
        // OP:- {city: 'Parasi', name: 'sumit', age: 17}
        // because we are copying the properties names of person1 object inside the person2 object with the help of [...] spread operator
        // gggggg
    </script>





































</body>

</html>