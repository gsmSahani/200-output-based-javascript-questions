<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Javascript Output Based Questoins</title>
</head>

<body>







    <script>
        // 1

        // let a = []
        // let b = []
        // console.warn(a == b)
        // console.warn(a === b)

        // Explanation: actually when we compare the two array either data type or strict comparison it will output false
        //because both the a and b has different location memory so comaring the different memory location it will show the ooutput false
        // False false

        // 2
        // let a = []
        // let b = a
        // console.warn(a == b)
        // console.warn(a == b)
        // now here it will show the output true because it is comparing the memory locatioon and the memory locatoin of the a and b is same like
        // we are assigning the value a to the variable b means the same memory location of a that's y it is true
        // Output: True true

        // 3
        // let a = [20]
        // let b = [20]
        // console.warn(a[0] == b[0])
        // console.warn(a[0] === b[0])

        // Explanation:
        // here it will behave in another way because here it is not comparing  the memory location
        // insted it is comparing the value of the array which is stored in the 1st index of the array
        // it like 20==20 and 20 === 20
        // Output: true,true

        // 4
        // let z = [1, 2, 3, 4, 5, 6]
        // let a = { name: "Gautam", age: 25 }
        // console.warn(...z)
        // console.warn(a.age)

        // Explanation:
        // Here in the first console it will pring the simle 1,2,3,4,5,6 it will be converted in string from array because of spread operator
        // and the 2nd console. it will pring the age of the object `a`
        // Output: 1,2,3,4,5,6 and 25

        // 5
        // console.warn(typeof NaN)

        // Explanation:
        // it will give the output of `number` and nan stands for not a number basically when we do any operation with string,object by number it will
        // show the error NaN and it also help to check whether the value is number or not
        // Output: number

        // 6
        // let arr = [1, 2, 3, 4, 5, 6];
        // arr.length = 0
        // console.warn(arr)

        // Explantaion:
        // it will show the op as empty array because we have set the length of the array to 0
        // Output: []

        // 7
        // x = 10
        // console.warn(x)
        // var x
        // Explanation :
        // because the of hoisting the declaration of the x is done at the top of the scope
        // Output: 10

        // 8
        // let a = { x: 1, y: 2 }
        // let b = a;
        // b.x = 3
        // console.warn(a)
        // console.warn(b)

        // Explantaion
        // both the value a and b are pointing to the same reference when the value is coming ffrom call by reference it will it will hold the same value to the parent also and to child also
        // and when the call by value is called the the parent value would be empty and the value get into the child
        // Output:{x: 3, y: 2} {x: 3, y: 2}


        // 9
        // for (var i = 0; i < 10; i++) {
        //     setTimeout(function () {
        //         console.warn("Value is" + i)
        //     });
        // }
        // Explanation:
        // because of the closure and setTimeOut function and the var is function scope and there will only one shared binding for the iterations
        // by the setTimeOut function gets executed because by default the setTimeOut delays the function to run in this case there is nothing so it delays 0ms
        //  the for loop has already completed and the value of the variable is 10
        // to fix this we can use let insted of var  because let has block scope but can't use const though it is block scope because the nature of the const variable
        // const is used for constant variable whose value should not and cannot be reassigned in this case if we use const the the value is going to change each time
        // Output: 10 times

        // 10
        // function hello() {
        //     console.warn("1")
        //     setTimeout(() => {
        //         console.warn("2")
        //     })
        //     console.warn("3")
        // }
        // hello()
        // Explanation:
        // 1st it will pring 1 followed by 3 and then after that it will pring the 2 because afte some delay it will print 2 because of asynchoronus settimeout
        // Output: 1 3 2

        // 11
        // let data = 10 - - 10
        // console.warn(data)
        // Explanation
        // it's simple bodmas rule that we use in maths (- * -) = +


        // 11
        // const set = new Set([1, 5, 2, 3, 4, 5])
        // console.warn(set)
        // Explanation:
        // it will automatically remove the duplicate value from the array and create new array
        // A set is js builtin object that is specially designed to hold the unique value
        // Output: Set(5){1,5,2,3,4}


        // 12
        // let data = { name: "Gautam" }
        // console.warn(delete data.name)
        // console.warn(data)
        // Explanation:
        // It will delete the property with the delete keyword and return boolean value `true`
        // when we check the data after deleting then it will reutrn empty object
        // Output: true

        // 13
        // const data = ["Gautam", "Pradep", "Rehman"];
        // const [y] = data;
        // console.warn(y)
        // Explanation
        // here it is being array destructuring extracting the 1st element of the data and assigning to the y variable
        // Output: Gautam

        // 14
        // const data = { name: "Gautam", age: 25, skill: "javascript" }
        // const { name } = data;
        // console.warn(name)
        // Question how to get the name without using . operator
        // it can be done with the help of data destructuring
        // Output Gautam

        // 15

        // let data = { name: "Gautam", age: 25, skill: "javascript" }
        // let info = { city: "Gautam", mail: "sahanigautam0446162@gmail.com" }
        // data = { ...data, ...info }
        // console.warn(data)
        // another method
        // let data = { name: "Gautam", age: 25, skill: "javascript" };
        // let info = { city: "Gautam", mail: "sahanigautam0446162@gmail.com" };

        // data = Object.assign({}, data, info);

        // console.warn(data);

        // Questions : How to merge these two object
        // We can achieve with the help of spread operator by assigning variable and spreading both the object into single variable inside {}
        // it can be achive by another method too example Object.assign() ,It performs a shallow copy of object properties, similar to the spread operator.

        // Note:
        //Object.assign() is widely supported across all modern browsers and is suitable for most scenarios where you need to merge objects.
        // Object Spread is more concise and readable but is currently a Stage 4 proposal and may require transpilation for older environments.

        // 16
        // const user = {
        //     firstName: "Gautam",
        //     getName() {
        //         const firstName = "Gautam Sahani";
        //         return this.firstName
        //     },
        // }
        // console.log(user.getName())
        //Explanation: this is due to method invocation `this` keyword is set to the object that own method
        // Output: Gautam



        // --------------------------
        //17
        // const name = "gautam";
        // console.log(name());

        // it will show the error TypeError: name is not a function because we are calling name() function which is not defined


        // 18
        // const result = false || {} || null;
        // console.log(result);
        // OP-{}
        // as we know when we use `OR ||` operator it is used to get the first truthy value and it evaluates from left to right
        // in this case false is falsy value and it goes to {} value an it found the value is truthy then it print the {} empty object
        // and return it immediately stops the execution after it gets the truthy value


        // 19
        // const result = null || false || '';
        // console.warn(result);
        // op-empty string ''
        // as we know `|| OR` it is logical operator it evaluates from left to right it always check the first truthy values
        // if it gets truthy value then it will print the first truthy value or else it will print the last value of the conditoins


        // 20
        // const result = [] || 0 || true;
        // console.warn(result)
        // op-[]
        // it will print the first truthy value as it is getting the first value as a true where it evaluates the
        // value from left to right

        // 21
        // console.log(Promise.resolve(5))
        // op-Promise {<fulfilled>: 5}
        // when we use promise reolved it return promise itself so it is fullfilled
        // specify the reason?

        // 22
        // JSON.parse()
        // OP-"undefined" is not valid JSON
        // Question: What will this method do
        // a. `Parse JSON to javascript Value`
        // b: Parse javascript object to JSON
        // c: Parse any javascript value to JSON
        // d; Parse JSON to object only



        // 23
        // let name = "Gautam"
        // function getName() {
        //     console.log(name)
        //     let name = 'Shambhu'
        // }
        // getName()
        // output:-ReferenceError: cannot access "name" before initialization
        // because of the hoisting the let and const is block scoped and var is function scoped
        // variable declared with the let and const is hoisted but not initialized with default value that's y it is showing the erro
        // the error we are getting is because of TDZ temporal dead zone



        // 24
        // let name = "Gautam"
        // function getName() {
        //     console.log(name)
        //     var name = 'Shambhu'
        // }
        // getName()
        // op:- undefined

        // because of the memory creation phase var is function scoped and var is hoisted and the value is initialized with undefined

        // 25
        // var a = 100;
        // {
        //     var a = 10;
        //     let b = 20;
        //     const c = 30;

        //     console.log(a);
        //     console.log(b);
        //     console.log(c);
        // }
        // console.log(a)
        // op:- 10,20,30,10
        // because block a is modified value of global `a` as well
        // here when var a =10 runs then 100 is replaced by 10 as it was initially in global scope
        // so if one has same name variable outside the block the variable inside the blocks shadow the outside variable
        // this is happening because of shadowing  and this happens only for var

        // 26
        // let name = "sumit"
        // function getName() {
        //     console.log(name)
        // }
        // getName()
        // output:- sumit
        // because we are accessing the let varialbe inside the function and invoking the function getName()

        // 27
        // console.log(`(x => x)('i love javascript')); here is x is returing the value of x
        // console.log(`${(x => x)('i love javascript')} to build frontend`);
        // output:- i love javascript to build frontend
        // because we are using arrow function and x is returning the i love javascript

        // 28
        // function sumValues(x, y, z) {
        //     return x + y + z;
        // }
        //console.log(sumValues([...1, 2, 3])) //1 is not iterable
        //console.log(sumValues([...[1, 2, 3]])) //op is  1,2,3, undefined undefined
        //console.log( sumValues(...[1, 2, 3])) //output is 6
        //console.log(sumValues([1, 2, 3])) //op is  1,2,3, undefined undefined

        // Options:
        // a: sumValues([...1,2,3])
        // b: sumValues([...[1,2,3]])
        // c: sumValues(...[1,2,3])
        // d: sumValues([1,2,3])


        //29
        // const name = 'cutratetraveller explore the world'
        // console.log(!typeof name === 'object') //false
        // console.log(!typeof name === 'string') //false
        // console.log(!typeof name === false) //true
        // output:- false false true
        // because our javascript execute the code line by line as it is single threaded and evaluates the value from left to right
        // when we are doing (! typeof name ) it is making the true value to false and checking the false value with the object
        // (typeof name ) op is true and we are making the true value false at begining by (!typeof name and then evaluating the value with === 'object')



        // 30
        // const name = "Join Cutratetraveller"
        // const age = 25
        // console.log(isNaN(name)) //true
        // console.log(isNaN(age)) //false
        // output:- true false
        // because it is checking whether the variable is storing the number of not


        // ------------07/24/2024
        // 31

        // let person = { name: 'Sumit' }
        // Object.seal(person)
        // question how can you modifiy the object person
        // person.push("Shambhu")
        // person.name = "Gautam" //it can be modified by this way
        // console.warn(person)
        // with this method it prevents the addition and deleteion of new properties
        // makes existing properties non configurable


        // 32
        // let data = [1, 2, 3, 4, 5] //remove the 1st and last element
        // data.shift() //removing the 1st elemtn
        // data.pop() //removing the last elemnet
        // data.push(1) //adding the elemnt at the last of the array
        // data.unshift(98) //adding the element at the 1st in array container
        // console.warn(data)

        // 33
        // convert the data into boolean false value
        // let data = "true"
        // console.warn(!data)
        // console.warn(data)
        // because whenever we keep the negation value infront of any variable conditon it will convert to boolean value if it is true convert to false and viceversa
        // Question: Convert the data into boolean true
        // let data = "true"
        // console.warn(!!data)
        // console.warn(data)
        // single negation symbol makes the value boolean value false but !! double negation value it makes the vale boolean true


        // 34
        // let data = ["gautam", "sumit", "shambhu"]
        // delete data[1]
        // console.warn(data)
        // console.log(data.length) // it will give the length 3
        // OP:-  ['gautam', empty, 'shambhu']
        // delete keyword is used to delete both the properties and propeties value of object in js
        // it deletes the index value properties which has index of 1 here 1=sumit
        // whenever we delete it create empty space



        // 35
        // how to merge two array
        // let arr1 = ["gautam", "sumit", 'shambhu']
        // let arr2 = ["MCA", "Scinetis", 'CEO']
        // let arr2 = [1, 2, 3, 4]
        // let mergeData = [...arr1, arr2]
        // console.log(mergeData)

        // this can be done with the help of spreap operator

        // 36
        // let c = 3 ** 3
        // console.warn(c)
        // here it is used js exponentiation operator it reaises the first operand to the power of the 2nd operand
        // another simple meaning 3 square 3




        // 37
        // let a = 2
        // setTimeout(() => {
        //     console.warn(a)
        // }, 0);
        // a = 100
        // OP:- 100
        // whenever we use setTimeout setTimeInterval in js engine the stack is created and it puts all the api function at last
        // that will run after all the program loc is executed as it becomes asynchronous and when all the loc is executed
        // at last the updated value is 100 and it prints 100 because at first the value of a was initialized to 2 and after that is was initialized to 100

        // 38
        // let a = 2
        // let A = 100
        // console.warn(A)
        // OP:-100
        // it will print the op as 100 because after declaring and initializing the value to the variable it is called immediately `A`
        // here both the "a" and "A" are different variable

        // 39
        // let A10 = "Gautam"
        // let 10A ="Sumit"
        // console.warn(A10)
        // console.warn(10A)
        // console.warn(A10) this will act normal without any error but  this will console.warn(10A) throw an error because the rule of declaring the variable in javascript
        // the variable declaration of the should not start with number

        // 40
        // let a = "hello"
        // let b = `hello`
        // console.log(a === b)
        // OP:- true
        // because both the a and b are the same string value hello content the confusion is made by the template literals string can be stored
        // by doubleq quote "", single quote '' and template literals `` backticks

        // 42
        // let a = 1
        // let b = 2
        // console.log(--b === a)
        // OP:- true
        // because of perfix Decrement operator (`--b`) --b decrements the value of b by 1 before using its value in the comparison. So, b becomes 1 after this operation.

        // 43
        // let a = 1
        // let b = 1
        // let c = 2
        // console.log(a === b === --c)
        // OP:- false
        // because when we compared the value of a and b it returned the boolean value "true" not 1 and after getting the value of b = true now comparing the value
        // true === 1 that's y it is showing false because it is comparing the boolean value with 1

        // 44
        // console.log(3*3)//9
        // console.log(3**3) //3*3*3 = 27 it saying value of square of 3  * 3
        // console.log(3***3) //syntax error

        // 45
        // console.log(a)
        // var a;
        // console.log(a)
        // OP:- undefined undefined
        // because on which is above the variable declaration var a is hoisted the default value is provided undefined by the memory creation phase of execution context
        // where as another console which is after declaration of var a is also undefined because we are accessing the value of the variable which is declared but not initialized with default value

        // 46
        // how to find the os name from js
        // navigator.platform

        // 47
        // function bike() {
        //     console.log(name)
        //     console.log(price)
        //     var name = "Dominor"
        //     let price = 262000;
        // }
        // bike()
        // OP:- Undefined, Reference Error cannot access price before initialization
        // because var is hoisted and it value is also hoisted but let is hoisted but not initialized with default value the value is in TDZ

        // 48
        // for (var i = 0; i < 3; i++) {
        //     setTimeout(() => {
        //         console.log(i)
        //     }, 1);
        // }
        // OP:- 3,3,3
        // because at first loop has executed 3 time 3 and when it finishes it's execution at that time value of var i = 3 and afte that it prints 3
        //The for loop completes before any of the setTimeout callbacks execute.
        // Each callback captures and logs the final value of i (which is 3), rather than the value of i at the time setTimeout was called.
        // This results in the console outputting 3 three times instead of 0, 1, 2

        // 49
        // for (let i = 0; i < 3; i++) {
        //     setTimeout(() => {
        //         console.log(i)
        //     }, 1);
        // }
        // OP:- 0,1,2
        // because let has block scope

        // 50
        // console.log(+true)
        // console.log(typeof +true)
        // OP:- 1 and number
        // because When you apply + to a boolean value (true), JavaScript converts true to its corresponding numeric representation, which is 1.
        // Therefore, +true evaluates to 1.


        // ---------------------- 07/26/2024
        // 51
        // console.log(!"gautam")
        // console.log(typeof ('gautam'))
        // OP:- false and string
        // because we are converting the string to the opposite that y it is returning false and 2nd console we are checking the type of data and it is string


        // 52
        // let data = 'size'
        // const bird = {
        //     size: "small"
        // }
        // console.log(bird[data]) //accessing the property of the bird using the value of data
        // console.log(bird["size"]) //it is directly accessing the property `size` of the bird object
        // console.log(bird.size) //it is also directly accessing the propery  of the bird object
        // console.log(bird.data) //it is trying to access the property of the data which is not available in brid object
        // OP:- small small small undefined
        // here (.) notation and bracket [] notation are straight forward way to access the object properties directly if you know the property name in advance
        // using the variable and accessing them inside the bracket (bird[data] allows for dynamic property access based on the value of the variable


        // 53
        // let c = { name: "gatuam" }
        // let d;
        // d = c;
        // c.name = "sumit"
        // console.log(d.name)
        // OP:- sumit
        // it will print sumit because due to shared object reference, mutability and object references c and d points to the same object
        // changing c.name to sumit also changes d.name because they share the same object reference

        // 54
        // var x;
        // var x = 10
        // console.log(x)
        // OP:- 10
        // because it holds the value of 10 here first x is declared in 1st step and in 2nd step x has initialized a value of 10

        // 55
        // var x
        // let x = 10
        // console.log(x)
        //OP:- syntaxerror x has been already declared
        // because here let and const cannot be redeclared and we are declaring the same variable name with let and assigning the value


        // 56
        // let a = 3
        // let b = new Number(3)
        // console.log(a == b) //true
        // console.log(a === b) //false
        // OP:- true and false
        // because we are comparing the number with object in 1st case type coercien takes place and it convert to the same value and check the vlalue
        // whereas in 2nd console log type coercien does not take place means it is comparing number with object which is obviously false


        // 57
        // let name;
        // name = {}
        // console.log(name)
        // OP:- empty object {}
        // because we are not assingnign any properties and value to the object name

        // 58
        // function bike() {
        //     console.log("Dominor")
        // }
        // bike.name = "BMW"
        // bike()
        // OP:- Dominor
        // bike.name = "BMW";: Assigns a property "name" to the function object bike. In JavaScript, functions are objects, so you can add properties to them.
        // This is because calling bike() executes the function body, which logs "Dominor" to the console.


        // 59
        // function sum(a, b) {
        //     return a + b
        // }
        // console.log(sum(5, "10"))
        // OP:- 510
        // because it is concatenating the number with string

        // 60
        // let number = 10
        // console.log(number++) //10
        // console.log(++number)//12
        // console.log(number) //12
        // because of postfix and prefix operator
        // Postfix (number++): Returns the current value of number, then increments number by 1.
        // Prefix (++number): Increments number by 1, then returns the incremented value.

        // 61
        // let f = "8";
        // let a = 1;
        // console.log((+f) + a + 1)
        // OP:-10
        // because the expression (+f) is a shorthand way to convert the value of f to a number.Therefore (+f) evaluates to 8

        // 62
        // let a = 10
        // if(true){
        //     let a = 20
        //     console.log(a, "inside")
        // }
        // console.log(b, "outside")
        // OP: 20 Inside and 10 Outside
        // because variable a is declared inside the block scope and does not affect the outside variable

        // 63
        // var a = "gautam"
        // var a = "sumit"
        // console.log(a)
        // OP:- sumit
        // here the variable is decalared with var keyword in which we can redeclare and assign value it overrides the previous variable value

        // 64
        // const arr1 = [1, 2, 3, 4];
        // const arr2 = [6, 7, 5];
        // const result = [...arr1, ...arr2];
        // console.log(result);
        // OP:- result [1,2,3,4,6,7,5]
        // here we are concatenating the two array into a single array with the spread operator [...]

        // 65
        // const person1 = { name: "sumit", age: 17, }
        // const person2 = { city: "Parasi", ...person1 }
        // console.log(person2)
        // OP:- {city: 'Parasi', name: 'sumit', age: 17}
        // because we are copying the properties names of person1 object inside the person2 object with the help of [...] spread operator

        // -----------------------07/27/2024--------------------
        // 66
        // function sum(a, b) {
        //     return a + b
        // }
        // console.log(sum(10, "20"))
        // OP:- 1020
        // because a number is concatenating the b string value

        // 67
        // function getAge(...args) {
        // console.log(Array.isArray(args)) //true
        // console.log(args) // [25]
        // console.log(typeof args) //object
        // }
        // getAge(25)
        // OP:- [25] object
        // because when you use `...args` syntax in function args becomes an array containing all the arguments passed to the functoin
        // arg is an array so typeof args became object and this is because array is an type of object
        // to confirm use `Array.isArray()` method

        // 68
        // function getAge() {
        //     'use strict'
        //     age = 25
        //     console.log(age)
        // }
        // getAge()
        // OP:Reference error : age is not defined at getAge()
        // because when we use strict mode  in javascript it enforces stricter parsing and error handling on your code
        // major imp is it prevents the accidental creation of global variable
        // here age is initialized but not declared so we have to declare the variable first and assign the value

        // 69
        // const sum = eval("10*5+5")
        // console.log(sum)
        // OP:-55
        // because it evaluates the expression from the string and calculate the number

        // 70
        // const obj = { 1: "a", 2: "b", 3: "c" }
        // console.log(obj.hasOwnProperty("1"))
        // console.log(obj.hasOwnProperty(1))
        // OP:-true true
        // in both the case the op will be true because `hasOwnProperty` check for the existence of the property
        // when we pass the number value as a key to check the js internally convert the number into string and check
        // so it "1" true

        // 71
        // for (let i = 1; i < 10; i++) {
        //     if (i === 3) continue
        //     if (i === 5) break
        //     console.log(i)
        // }
        // OP:1,2,4
        // because here we are using continue statement which says to skip the current iteration and continue with other
        // and break statement will break the iteration and terminate the program

        // 72
        // const foo = () => console.log('first')
        // const bar = () => setTimeout(() => console.log('second'))
        // const baz = () => console.log('Third')
        // bar() // wait for foo and baz
        // foo() // executes first
        // baz() //executes after the foo
        // OP:- first second and third
        // because the both foo and baz will run automatically but here in the case of bar() function it has settimeout which is webapi
        // it will hold in the task queue from the web api and it goes into the call stack when foo and baz is cleared from the call stack that's y it is printing first third and second


        // 73
        // const person = { name: "gautam" }
        // function sayHi(age) {
        //     return `${this.name} is ${age}`
        // }
        // console.log(sayHi.call(person, 21))
        // console.log(sayHi.bind(person, 25))
        // console.log(sayHi.call(person, 21)) outputs "gautam is 21".
        // console.log(sayHi.bind(person, 25)) outputs the function definition.
        // because call method is immediately invoked the function with specifinc "this" context and arguments
        // but bind method reutrn a new funcitoin with a specific `this` context and preset arguments and the new function can be called later

        // 74
        // function sayHi() {
        //     return (() => 0)()
        // }
        // console.log(typeof sayHi())
        // OP:number
        // because sayHi function is returning another arrow funciton which has number 0

        // 75
        // console.log(typeof typeof 1)
        // OP:- string
        // NOTE:the typeof operator returns a string that describe the type of the value

        // typeof 1 results in "number".
        // typeof "number" (where "number" is the result of typeof 1) results in "string".

        // 76
        // const numbers = [2, 4, 6, 8]
        // numbers[10] = 12;
        // console.log(numbers)
        // OP:-[2, 4, 6, 8, empty × 6, 12]
        // here numbers[10] means to keep 12 at the index number of 10 which is followed by 0=2,1=4,2=6,3=8 4=[],5=[],6=[],7=[],8=[],9=[],10=[12]

        // 77
        // const numbers = [2, 4, 6, 8]
        // numbers[10] = numbers;
        // console.log(numbers)
        // OP:- [2, 4, 6, 8, empty × 6, Array(11)]
        // it will go to infinite number of inserting the numbers array to the index number of 10

        // 78
        // Everything in javascript is either a..
        // A:primitive or object  //true
        // B:function or object
        // C:only object
        // D:number or object


        // 79
        // console.log(!!null) //false
        // console.log(!!"") //false
        // console.log(!!1) //true
        // NOTE : ! single exclamantion marks This operator is used to negate a value, converting it to its boolean opposite.
        // !! (Double Exclamation Mark):Applying ! twice first negates the value (turning a truthy value to false and a falsy value to true),
        // !! is used to explicitly convert a value to its boolean equivalent.
        // Falsy values (like null, "", 0, NaN, and false) become false
        // and truthy values (like 1, "hello", {}, []) become true.

        // 80
        // console.log(setInterval(() => console.log("hi"), 1000))
        // console.log(setInterval(() => console.log("hi"), 1000))
        // console.log(setInterval(() => console.log("hi"), 1000))
        // 1 2 3 (hi hi hi) to the inifinite
        // because Each call to setInterval returns a unique interval ID here in this code  Intervalid is 1,2,3, which you can use to stop the interval using clearInterval.

        // 81
        // console.log([..."gautam"])
        // OP:- ['g', 'a', 'u', 't', 'a', 'm']
        // here we are using spread operator which is breaking down the string element into the new  array element

        // 82
        // const firstPromise = new Promise((resolve, reject) => {
        //     setTimeout(resolve, 500, "one")
        // })
        // const secondPromise = new Promise((resolve, reject) => {
        //     setTimeout(resolve, 100, 'two')
        // })
        // Promise.race([firstPromise, secondPromise]).then(resolve => console.log(resolve))
        // Since secondPromise resolves first because it has the timer of only 100ms and firstPromise has timer of 500ms, the output of console.log(resolve) will be "two",
        // because secondPromise resolves with "two" after 100 milliseconds.

        // 83
        // let person = { name: "sumit" }
        // const members = [person]
        // person = null
        // console.log(members)
        // OP:-[ { name: 'sumit' } ]
        // The array members still holds the original object with name: "sumit", despite the person variable being reassigned to null.
        // when we are assinging the the person null the person becomes null but before assigning it null we have kept the person object to the members array
        // and we are doing console to the members and member is still holding the original array

        // 84
        // const person = {
        //     name: "Shambhu",
        //     age: 43,
        // }
        // for (const item in person) {
        //     console.log(item)
        // }
        // OP: name and age
        // because the work of for in loop is to iterate over the properties of the object only

        // 85
        // let data = 10 + 20 + "30"
        // console.log(data)
        // OP:- 3030
        // because we are adding the 10+20 and becomes 30 and the last value is string so we cannot add string with number and there + sign used
        // which works as string concatenation


        // 86
        // console.log(typeof 10 + 20 + "30")
        // console.log(typeof 3 + 4 + +'5')
        // OP:- number 45
        // OP:- number 2030
        //  because as we know the js evaluates from left to right first it check the typeof 10 it comes number and after add remaining part 2030


        // 87
        // console.log([] === []);
        // OP:-false
        // because the both the array is stored in different memory location

        // 88
        // let data = [1, 2, 3].map(num => {
        //     if (typeof num === 'number') return
        //     return num * 2
        // })
        // console.log(data)

        // OP:-[undefined, undefined, undefined]
        // The map method replaces each element in the new array with undefined,
        //  because the callback function only returns a value when the condition is not met,
        //  but in this case, the condition is always met (i.e., all elements are numbers).

        // 89
        // function getInfo(member) {
        //     member.name = "Sumit"

        // }
        // const person = { name: "Gautam" }
        // getInfo(person)
        // console.log(person)
        // OP:-{ name: "Sumit" }
        // this is happening because in javascript objects are passed by reference.
        // Therefore, any changes made to an object inside a function will be reflected outside the function as well. In this case,
        // the name property of person is changed from "Gautam" to "Sumit".

        // 90
        // function Car() {
        //     this.make = 'Thar';
        //     return { make: "Rubicon" }
        // }
        // const myCar = new Car()
        // console.log(myCar.make)
        // OP:- Rubicon
        // because we are returning the property value and it is overriding the previous object value with Rubicon

        // 91

        // console.log(5 < 6 < 7)
        // console.log(7 > 6 > 5);  //false
        // OP:- True
        // as we know that js evaluates the expression from left to right the expression here is compared first 5<6 true and it implicitly convert
        // the true into number 1 and after that it compares 1<7 true and that's y the op is true

        // 92
        // console.log(0 == false)
        // console.log(1 == true)
        // true true
        // The == operator converts operands to a common type before making the comparison. In both the cases,
        // the boolean value will be converted to a number, i.e., false is converted to 0 and true is converted to 1.
        //  So, the expression 0 == false is equivalent to 0 == 0 and 1 == true is equivalent to 1 == 1.

        // 93
        // console.log([10, 20, 30] + [18, 12, 78])
        // OP:-10,20,3018,12,78
        // the + operator is used for both in addition and concatenation ,it is because when we concatenate two array then it converted into string and concatenate
        // "10,20,30""18,12,78"


        // 94
        // console.log({} == {})
        // console.log({} === {})
        // OP:- false
        // because it is comparing both the empty object but he objet are loacted in different memory location

        // 95
        // let x = 5;
        // let y = x++;
        // console.log(y);
        // console.log(x)
        // OP:- 5,6
        // because it's all game of post increment
        // console.log(y); will print 5, because y was assigned the value of x before x was incremented.
        // console.log(x); will print 6, because x was incremented after its value was assigned to y.

        // 96
        // let x = 5;
        // let y = ++x;
        // console.log(x)
        // console.log(y);
        // OP:- 6,6
        //  The pre-increment operator increments and returns the value after incrementing.


        // 97
        // console.log('apple'.split(''))
        // OP:['a', 'p', 'p', 'l', 'e']
        // because split method is used to split a string into array of substrings based on specifid operators

        // 98
        // const arr = [10, 20, 50, 60, 80, 100]
        // console.log(arr.indexOf(80))
        // OP:- 4
        // this is because indexOf method returns the index number of the array element

        // 99
        // const array = [10, 20, 50, 60, 80, 100]
        // const result = array.map(element => element + 2).filter(element => element > 50)
        // console.log(result)
        //OP:- [52, 62, 82, 102]
        // here first iterating the each array element and adding 2 to all the arrr element 10+ 2=12 like this after getting all the elemnt by adding
        // now it is using filter method to filter the value of array element which is greater than 50

        // 100
        // function checkValue(value) {
        //     var result = Array.isArray(value);
        //     console.log(result);
        // }
        // checkValue([1, 2, 3]);
        // OP:-true
        // because it Array.isArray check the if the value is array or not



        // 101
        // const obj = {
        //     a: "foo",
        //     b: function () {
        //         console.log(this.a)
        //     }
        // }
        // const c = obj.b
        // obj.b()
        // c()
        // foo
        // undefined
        // because when obj.b is called `this` referes to `obj` so this.a is "foo"
        // and when c() invoked this refers to the global object and the global object has assigned the value of undefined


        // 102
        // const arr = [10, 20, 30, 40, 50, 60, 70]
        // for (var i = 0; i < arr.length; i++) {
        //     setTimeout(() => {
        //         console.log(i)
        //     }, 1000);
        // }
        // 7 five times
        // it mainly happening due to the closure and setTimeout
        // The var keyword in JavaScript has function scope, not block scope.
        // This means that the variable i is not re-declared for each iteration of the loop;
        //  there is a single i variable that all the closures created by setTimeout share.
        // By the time the setTimeout callbacks are executed (after 1 second), the for loop has completed, and i has been incremented to 7
        // to get rid of this we can use let or iife


        // 103
        // let a = {}
        // let b = { name: "Gautam" }
        // let c = { name: "sumit" }

        // a[b] = 123
        // a[c] = 456
        // console.log(a[b])
        // 456
        // The reason for this behavior is that when you use objects as keys in a JavaScript object,
        //  they are implicitly converted to strings, and all objects convert to the same string [object Object].
        //  This results in the key collision and the value being overwritten.
        // Since both b and c convert to the same string key [object Object],
        //  the second assignment (a[c] = 456) overwrites the first assignment (a[b] = 123).

        // 104
        // let obj1 = { key: "value" };
        // let obj2 = obj1;
        // let obj3 = obj2;
        // obj1.key = "new value";
        // obj2 = { key: "another value" };
        // console.log(obj1.key, obj2.key, obj3.key);
        // new value, another value,new value
        // in javascript object are assigned and passsed by     reference
        // obj1, obj2, and obj3 all initially reference the same object { key: "value" }.
        // Changing obj1.key to "new value" updates the key property of the single object referenced by all three variables.
        // Reassigning obj2 to { key: "another value" } only changes what obj2 points to,
        // creating a new object and leaving obj1 and obj3 still referencing the original object.

        // 105
        // const x = { add: 1 }
        // const y = { add: 2 }
        // function addTwo(obj) {
        //     return obj.add + 1
        // }
        // console.log(addTwo(x))
        // console.log(addTwo(y))
        // 2,3
        // because we are adding the 1 to all the add properties of the x and y object and returning in addTwo function by passing parameter obj

        // 106
        // let obj = {
        //     a: 10,
        //     b: 20,
        // }
        // let x = obj
        // obj.a = 50
        // console.log(obj)
        // console.log(x)
        // {a: 50, b: 20},{a: 50, b: 20}
        // because both obj and x point to the same object,obj and x are two variables referencing the same object.
        // console.log(obj) outputs { a: 50, b: 20 } because the a property has been updated to 50.
        // console.log(x) also outputs { a: 50, b: 20 } because x references the same object and thus reflects the same changes.


        // 107
        // let a = [2, 4, 6, 8, 10]
        // let b = [2, 4, 6, 8, 10]
        // let c = b
        // console.log(b)
        // console.log(a == b) //false
        // console.log(a === b) //false
        // console.log(c == b) //true
        // console.log(c === a) //false
        // console.log(c == b) //true
        // a== b is false because both the array are located into different memory location
        // a === b again false because the memory location is different for both the variable a and b
        // c == b yes it is true because it is getting the reference value of the b array which is stored in the same location
        // c === b is false because again it's memory allocation

        // 108
        // let a = 30;
        // let b = a++
        // console.log(a)
        // console.log(b)
        // 31 30
        // because of post increment


        // 109
        // let num = 0
        // function hello() {
        //     var num = 1
        //     return num;
        // }
        // console.log(hello()) //1
        // console.log(num) //0
        // because the hello() funciton is invoked first andthen num is called in console

        // 110
        // let obj = { name: 'gautam', age: 24 }
        // let obj2 = { ...name, age: 50 }
        // console.log(obj.age) //24
        // console.log(obj2.age) //50
        // because we are using spread operator for copying the 1st object into the 2nd object

        // 111
        // const add = (a = 10, b = 20) => a + b
        // console.log(add()) //30
        // console.log(add(50)) //70
        // console.log(add(undefined, 50)) //60
        // because we are overwriting the default value passed in the parameter which if we do not pass any value then
        // it will take the defalult value but if we give value then it will override


        // 112
        // console.log(typeof NaN) //number
        // console.log(typeof undefined) //undefined
        // console.log(typeof null) //object
        // console.log(null === undefined) //false
        // console.log(null == undefined) // true
        // console.log(null === false) //false
        // console.log(Number === NaN) //false

        // because
        // typeof NaN returns "number" because NaN is considered a numeric type.
        // typeof undefined returns "undefined" because undefined is its own type.
        // typeof null returns "object" due to a historical bug in JavaScript.
        // null === undefined is false because they are of different types.
        // null == undefined is true due to loose equality treating them as equivalent type coercion is taking place.
        // null === false is false because null and false are of different types.
        // Number === NaN is false because Number is a constructor and NaN is a value.

        // 113
        // console.log(typeof 100) //number
        // console.log(typeof "gautam") //string
        // console.log(typeof [2, 4, 6, 8]) //object
        // console.log(typeof {}) //object
        // console.log(typeof function () { }) //function
        // console.log(typeof NaN) //number
        // console.log(typeof true) //boolean
        // console.log(typeof undefined) //undefined
        // console.log(typeof Date) // function
        // console.log(typeof Date()) // string
        // console.log(typeof Date.now()) //number

        // 114
        // let a = 10
        // {
        //     let a = 20
        //     console.log(a)
        // }
        // console.log(a)
        // 20 and 10
        // because the let is block scoped hence we are calling the block a inside the block andit is executed 1st and
        // then after that outer block scope

        // 115
        // let a = 20
        // function display() {
        //     console.log(a)
        //     let a = 40
        // }
        // display()
        // Hoisting with let: let declarations are hoisted to the top of their block scope but are not initialized, causing a temporal dead zone.
        // ReferenceError: Accessing a let variable before its declaration in its block results in a ReferenceError.
        // The let keyword creates a block-scoped variable. This means the a inside the display function is local to that function and shadows the global a.
        // hoisting and function scope and shadowing the global a

        // 116
        // let a = 10;
        // function abc() {
        //     if (true) {
        //         let b = 20;
        //         console.log(b); //20
        //     }
        //     console.log(a); //10
        // }
        // abc();
        // Inside the if block, let b = 20; is declared and is accessible only within the block.console.log(b); prints 20.
        // Outside the if block, console.log(a); prints the value of the global a, which is 10

        // 117
        // const person = {
        //     name: "gautam",
        //     age: 25
        // }
        // Object.freeze(person)
        // person.age = 50
        // console.log(person.age)
        // OP:- 25
        // Object.freeze(person): This makes the person object immutable.
        // Modification Attempt: Trying to change person.age after freezing it has no effect.
        // object.freeze prevents modification to the person object

        // 118
        // function hi() {
        //     console.log(name)
        //     console.log(age)
        //     var name = "gautam"
        //     let age = 25
        // }
        // hi()
        // OP:- undefined and reference error
        // Explanation:
        // The variable 'name' is hoisted with the default value 'undefined' because 'var' is function-scoped.
        // The variable 'age' is hoisted but cannot be accessed before initialization because 'let' has block scope and a Temporal Dead Zone (TDZ).

        // 119
        // for (var i = 0; i < 3; i++) {
        //     setTimeout(() => {
        //         console.log(i)
        //     }, 1);
        // }
        // for (let i = 0; i < 3; i++) {
        //     setTimeout(() => {
        //         console.log(i)
        //     }, 1);
        // }
        // Output: 3 3 3 and 0 1 2

        // Explanation:
        // - `var` is function-scoped or globally scoped, not block-scoped.
        // - The variable `i` is hoisted to the top of the function or global scope.
        // - The `for` loop completes its iterations, and `setTimeout` schedules functions to run after the loop.
        // - All the `setTimeout` functions reference the same `i`.
        // - By the time the functions run, the loop has finished, and `i` is `3`.
        // - Therefore, each function logs `3`.

        // - `let` is block-scoped, creating a new `i` for each iteration of the loop.
        // - Each iteration of the `for` loop has its own scope for `i`.
        // - The `setTimeout` functions capture the `i` from their respective iterations.
        // - When the functions execute, they log the values `0`, `1`, and `2` from their own iteration scopes.

        // 120
        // const shape = {
        //     radius: 10,
        //     diameter() {
        //         return this.radius * 2
        //     },
        //     perimeter: () => 2 * Math.PI * this.radius
        // };
        // shape.diameter()
        // shape.perimeter()
        // Output: 20 NaN

        // Explanation:
        // `diameter` is a regular function, so `this` refers to the `shape` object itself.
        // The calculation is `this.radius * 2`, which is `10 * 2 = 20`.

        // `perimeter` is an arrow function, so `this` does not refer to the `shape` object.
        // Instead, it inherits `this` from the surrounding context, which is the global context.
        // In the global context, `this.radius` is `undefined`.
        // The calculation becomes `2 * Math.PI * undefined`, resulting in `NaN`.


        // 121
        // console.log(+true)
        // console.log(!"Gautam")
        // Output: 1 and false

        // Explanation:

        //  `+true`:
        //    - The unary plus operator attempts to convert its operand to a number.
        //    - The boolean value `true` is converted to the number `1`.
        //    - Therefore, `+true` results in `1`.

        // `!"Gautam"`:
        //    - The string `"Gautam"` is a non-empty string, which is considered `truthy` in JavaScript.
        //    - The logical NOT (`!`) operator negates the truthy value.
        //    - Therefore, `!"Gautam"` results in `false`.

        // 122
        // let a = { greeting: "Hi" }
        // let b;
        // b = a
        // a.greeting = "Hello everyone"
        // console.log(b.greeting)
        // Output: Hello everyone

        // Explanation:

        // 1. Objects in JavaScript are assigned and passed by reference.
        //    This means that the variable `a` contains a reference to an object in memory.

        // 2. When `b = a;` is executed, `b` is assigned the same reference that `a` holds.
        //    Both `a` and `b` now refer to the same object in memory.

        // 3. When `a.greeting = "Hello everyone";` is executed, the `greeting` property of the object
        //    is updated. Since `a` and `b` refer to the same object, this change is visible through both variables.

        // 4. Therefore, `console.log(b.greeting);` outputs "Hello everyone", reflecting the updated value
        //    of the `greeting` property in the shared object.

        // 123
        // let a = 10
        // let b = new Number(10)
        // let c = 10
        // console.log(a == b)
        // console.log(a === b)
        // console.log(b === a)
        // OP:- true false false
        // a == b: true(due to type coercion where b is converted to its primitive value for comparison).
        // a === b: false(because a is a primitive and b is an object, thus they are different types).
        // b === c: false(since b is an object and c is a primitive number, they are different types).


        // 124
        
    </script>









































</body>

</html>